- **什么是虚拟内存，什么是物理内存**

- **进程和线程**
	- 进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。
	- 进程是程序的一次执行，包括代码和数据，是CPU分配资源的基本单位，一个进程可以包括多个线程。进程之间通信方式：管道、SOCKET、信号量（互斥、同步）等。
	- 子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。
	- 线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
	- 线程是独立运行和独立调度的基本单位（线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度），线程之间共享进程的数据空间（借此通信）

- **线程同步的方式有哪些？**
	- 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
	- 信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
	- 事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

- **进程间的通信方式**

	主要分为：管道、系统IPC（包括信号量，消息队列、信号量、共享存储）、SOCKET
	- 管道主要分为：普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe）
	管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间活动，进程的亲缘关系通常是父子进程
	命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信
	- 系统IPC
		- 信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。
		- 消息队列是消息的链表，存放在内核中并由消息队列标识符标识。
		- 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
		- 共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。

- **什么是临界区？如何解决冲突？**

	每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进入后不允许其他进程进入。
	- 如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入；
	- 任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；
	- 进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区；
	- 如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。

- **什么是缓冲区溢出？有什么危害？其原因是什么？**
	- 缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。
	- 危害有以下两点：
		1. 程序崩溃，导致拒绝额服务
		2. 跳转并且执行一段恶意代码
	- 造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入.

- **进程有哪几种状态？**
	- 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源
	- 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数
	- 阻塞状态： 进程等待某种条件，在条件满足之前无法执行

- **分页和分段有什么区别**
	- 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。
	- 段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定
	- 段向用户提供二维地址空间；页向用户提供的是一维地址空间
	- 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。

- **进程的调度算法**
	- FCFS(先来先服务)，优先级，时间片轮转，多级反馈
	- Linux进程调度采用的是抢占式多任务处理，所以进程之间的挂起和继续运行无需彼此之间的协作。
	- 调度方式：时间片，优先级，还有就是时间片加优先级混合，默认是第三种

- **说一说进程同步有哪几种机制。**
	- 原子操作、信号量、管程、会合、分布式系统

- 文件系统

- 内存分配策略

- 实现临界区的方法
	- 软件实现
	- 中断屏蔽（关中断，开中断）
	- 硬件指令方法

- 死锁产生的原因
	- 互斥条件：一个资源一次只能被一个进程使用
	- 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
	- 请求和保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
	- 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系

- 死锁的处理策略
	- 预防死锁
		设置某些限制条件，破坏产生死锁的四个必要条件中的一个或者几个
		- 破坏互斥条件
		- 破坏不剥夺条件
		- 破坏请求和保持条件
		- 破坏循环等待条件
	- 避免死锁
		在资源的动态分配的过程中用某种方法防止系统进入不安全状态从而避免死锁
		- 系统安全状态
		- 银行家算法
		- 安全性算法
	- 死锁的检测和解除
		- 资源分配图
		- 死锁定理
		- 死锁解除
- 多线程加锁

	多线程调用时要进行保护时，主要是针对全局变量和静态变量的，函数内的局部变量不会受到影响

- 互斥锁和信号量

	信号量是一种同步机制，可以当作锁来用，但也可以当做进程/线程之间通信使用，作为通信使用时不一定有锁的概念；互斥锁是为了锁住一些资源，是为了对临界区做保护

- malloc实现原理
	- 可以基于伙伴系统实现，也可以使用基于链表的实现
	- 将所有空闲内存块连成链表，每个节点记录空闲内存块的地址、大小等信息
	- 分配内存时，找到大小合适的块，切成两份，一分给用户，一份放回空闲链表
	- free时，直接把内存块返回链表
	- 解决外部碎片：将能够合并的内存块进行合并

- 使用mmap读写文件为什么比普通读写函数要快？

	mmap函数：可以将文件映射到内存中的一段区域，普通函数读写文件：用户空间buffer内核空间buffer磁盘；mmap映射之后：用户空间buffer进程内存空间，省掉了拷贝到内核空间的时间?

- Linux中如何实现Signal？

	基于软中断，不同Signal对应不同中断处理函数


- 简单的读写锁
	```c
	count_mutex = mutex_init();
	write_mutex = mutex_init();
	read_count = 0;
	void read_lock {
	 lock(count_mutex);
	 read_count++;
	 if (read_count == 1) {
	  lock(write_mutex);
	 }
	 unlock(count_mutex);
	}

	void read_unlock {
	 lock(count_mutex);
	 read_count--;
	 if (read_count == 0) {
	  unlock(write_mutex);
	 }
	 unlock(count_mutex);
	}

	void write_lock {
	 lock(write_mutex);
	}

	void write_unlock {
	 unlock(write_mutex);
	}
	```

