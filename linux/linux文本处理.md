# linux文本处理的常用的命令
## sed
sed是用程序进行文本编辑的流编辑器，只支持简单的条件处理，sed并不会改变文件内容，sed的工作方式是读取档案内容，经串流编辑之后，显示到标准输出，因此想要存储sed的结果，得自己运用转向输入输出结果到其他档案。(也可以用-i选项但是一般不建议，防止出错)

###常用选项：

- -n∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。
- -e∶直接在指令列模式上进行 sed 的动作编辑；
- -f∶直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作；
- -r∶sed 的动作支援的是延伸型正规表示法的语法.（预设是基础正规表示法语法）
- -i∶直接修改读取的档案内容，而不是由萤幕输出.
### 常用命令： 
- a∶新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)
- c∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
- d∶删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
- i∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
- p∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作～
- s∶取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！

### sed处理文本的一般格式为:
**sed '命令格式'  文件名**
//表示搜索的意思

####删除
- 删除第一行: `sed '1d' data.txt`
- 删除第二行到最后一行: `sed '2,$d' ab`
- 删除某一段范围内的文字，把1~4行的内容全部删除：`sed '1,4d' data.txt`
- 把含有hello字符串的行全部删除:`sed '/hello//g' data.txt`
- 把空行删除:`sed '/^$/d' data.txt`
- 把不包含hello的行全部删除:`sed '/hello/!d'data.txt`

####显示某行
- 把含有hello的行显示出来,由于sed会默认把不匹配的也显示一遍，所以加上-n参数，不显示未匹配的
`sed -n '/hello/p' data.txt`
- 显示第二行到最后一行:`sed -n '2,$p' ab`

####增加数据
- 第一行后增加字符串"hello":`sed '1a hello' ab' data.txt`
- 一行到第三行后增加字符串"hello":`sed '1,3a drink tea' data.txt`
- 第一行后增加多行，使用换行符\n:` sed '1a hello1\nhello2' data.txt`

####替换
- 取代，其中s代表的意思是取代，第一个//中表示搜索需要替换的字符串，第二个//表示替换的字符串，上面这个命令只会更换查找到的第一个字符串，如果需要更改所有的字符串需要把末尾改为g,g表示全局的意思
- 第一行代替为hello:`sed '1c hello' data.txt`
- 把含有hello的替换为hi:`sed -n 's/hello/hi/g' data.txt`
- 找到符合的行后，再进行取代，比如找到含有hello的那一行，把所有的111改为222:`sed -n '/hello/s/111/222/g' data.txt`
- 把1~4行中的111改为222:`sed -n '1,4s/111/222/g'`

## awk

AWK是文本处理语言，常用来进行查询，支持正则表达式，一般用来处理格式化报表，awk的常用格式主要有三种：
1. `awk 样式 文件名`
2. `awk '{动作}'`
3. `awk '样式{动作}'`

**awk的自建变量：**

变量|意义
---|---
\$0 | 当前记录（这个变量中存放着整个行的内容）
\$1~\$n|当前记录的第n个字段，字段间由FS分隔
FS|输入字段分隔符 默认是空格或Tab
NF|当前记录中的字段个数，就是有多少列
NR|已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。
FNR|当前记录数，与NR不同的是，这个值会是各个文件自己的行号
RS|输入的记录分隔符， 默认为换行符
OFS|输出字段分隔符， 默认也是空格
ORS|输出的记录分隔符，默认为换行符
FILENAME|当前输入文件的名字

- 显示含有hello的行

`awk '/hello/' data.txt`

- 显示不含有hello的行

`awk '!/hello/' data.txt`

- 显示每一行的第一个和第二个列（默认以空格分割列）

`awk '{print $1,$2} data.txt'`

- 显示含有hello的行的第一列和第二列

`awk '/hello/{print $1,$2}' data.txt`

- 更改默认的分列的符号，把空格改为以：号分割每一列,如果指定多个分隔符可以-F[;,.]这样

`awk -F: '{print $1,$2}' data.txt`

- 以，为默认的分割符号（两种都可以	）
	- `awk -F: 'EBGIN {OFS=','}{print $1,$2}' data.txt`
	- `awk -F: '{print $1,$2}' OFS="," data.txt1`

- awk还可以格式化输出(和上面一个输出同样的格式)：

`awk -F: '{printf"%d,%d\n",$1,$2}' data.txt`

- awk可以用条件来过滤数据,比如我们有个.csv的学生的成绩的文件，其中一位同学的名字为Tony(注意.csv文件默认以，来分割某一列)：

`awk -F,'$1=="Tony"{print $1,$2}' data.csv`

- 去掉列表的表头只需要判断NR！=1就可以
## grep
### 主要参数
参数|功能
---|---
-c|只输出匹配的行
-i|匹配不区分大小写
-n|显示匹配行的行号
-l|查询包括多个文本的时候，只输出包含匹配字符的文件名
-v|反向匹配，即显示不匹配的行
-h|查询的时候不显示文件名
-s|不显示错误的信息
-r|递归的搜索一个文件夹里面的所有文件
--color=auto|为匹配的关键词添加颜色显示

很多时候我们不关心匹配的行，而是关心匹配的上下文，这是就需要用到这样的参数了

参数|功能
---|---
-A n |显示匹配行之后的n行
-B n |显示匹配行之前的n行
-C n |显示匹配行的前n行和后n行

grep不支持一些正则表达式比如+，|之类的这时候就需要用到egrep了，egrep是对grep的扩展，增加了额外的正则表达式元字符集