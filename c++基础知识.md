- **多态性都有哪些？（静态和动态，然后分别叙述了一下虚函数和函数重载)**
多态：指当不同的对象收到相同的消息时，产生不同的动作
编译时多态：函数重载、运算符重载——静态绑定
运行时多态：虚函数机制——动态绑定
- **重写、重载、重定义**
 - 重写(override):
	父类与子类之间的多态性。子类重新定义父类中有相同名称和参数的虚函数。
	1. 被重写的函数不能是static的。必须是virtual的(即函数在最原始的基类中被声明为virtual )。
	2. 重写函数必须有相同的类型，名称和参数列表(即相同的函数原型)
	3. 重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public,protected也是可以的
 - 重载(overload):
	指函数名相同，但是它的参数表列个数或顺序，类型不同。但是不能靠返回类型来判断。
 - 重定义(redefining):
 	子类重新定义父类中有相同名称的非虚函数(参数列表可以不同)。
	重写与重载的区别 (override) PK (overload)
	1. 方法的重写是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关   系，是水平关系。
	2. 重写要求参数列表相同；重载要求参数列表不同。
	3. 重写关系中，调用那个方法体，是根据对象的类型（对象对应存储空间类型）来决定；重载关系，是根据调用时的实参表与形参表来选择方法体的。

- **动态绑定怎么实现？（就是基类与派生类指针和引用的转换问题**
   C++ 中，通过基类的引用或指针调用虚函数时，发生动态绑定。引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指对象的实际类型所定义的。

- **c++的四种类型强制转换**
 1. dynamic_cast：该转换符用于将一个指向派生类的基类指针或引用转换为派生类的指针或引用
 2. const_cast：最常用的用途就是删除const属性；
 3. static_cas：该操作符用于非多态类型的转换，任何标准转换都可以使用他，即static_cast可以把int转换为double，但不能把两个不相关的类对象进行转换，比如类A不能转换为一个不相关的类B类型。static_cast本质上是传统c语言强制转换的替代品。
 4. reinterpret_cast：该操作符用于将一种类型转换为另一种不同的类型，比如可以把一个整型转换为一个指针，或把一个指针转换为一个整型，因此使用该操作符的危险性较高，一般不应使用该操作符。

- 操作符重载（+操作符），具体如何去定义，？（让把操作符重载函数原型说一遍）
- **内存对齐的原则？（原则叙述了一下并举例说明**
  32位按照4字节对齐，64位按照8字节对齐。

- **模版怎么实现？**
```
template\<typename T>
中间不能有任何其他定义
void swap(T a,T b){}
```

- 指针和const的用法？（就是四种情况说了一下）

- 虚函数、纯虚函数、虚函数与析构函数？（纯虚函数如何定义，为什么析构函数要定义成虚函数）

- **内联函数与宏**
	1. 内联函数在运行时可调试，而宏定义不可以;
	2. 编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会；
	3. 内联函数可以访问类的成员变量，宏定义则不能；
	4. 在类中声明同时定义的成员函数，自动转化为内联函数
	5. 宏只是预定义的函数，在编译阶段不进行类型安全性检查，在编译的时候将对应函数用宏命令替换。对程序性能无影响

- const和typedef（主要讲了const的用处，有那些优点
- **排序算法有哪些？快速排序怎么实现的？最好时间复杂度，平均时间复杂度**
	排序算法|最坏时间复杂度啊|平均时间复杂度|空间复杂度
	-------|--------------|-----------|--------
	冒泡排序|$n^2$         |$n^2$	   |O(1)
	计数排序|$n^2$         |$n^2$      |O(1)
	插入排序|$n^2$		   |$n^2$      |O(1)
	选择排序|$n^2$         |$n^2$	   |O(1)
	堆排序  |$nlogn$       |$nlogn$    |O(1)
	归并排序|$nlogn$       |$nlogn$    |O(n)
	快速排序|$n^2$         |$nlogn$    |$nlogn$

- **链接指示：extern “C”（作用）**
 - extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。
 - 也就是说extern有两个作用，第一个,当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的"脾气"了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊,C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。
 - 当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g\_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。


- c语言和c++有什么区别？（大体讲了 一下，继承、多态、封装、异常处理等）
- stl有哪些容器，对比vector和set？
- 继承机制中对象之间是如何转换的？
- 继承机制中引用和指针之间如何转换？
- 虚函数，虚函数表里面内存如何分配？（这个考前看过了，答的还不错）

- **如何实现只能动态分配类对象，不能定义类对象？（这个牛客上的题目，我把如何只能动态分配和只能静态分配都讲了一下）**
动态分配类对象：就是使用运算符new来创建一个类的对象，在堆上分配内存。
静态分配类对象：就是A a，由编译器创建类对象，在栈上分配内存。
- 动态分配类对象
把类的构造函数和析构函数设为protected属性。类对象不能访问，但是派生类可以继承，也可以访问。
同时，创建create和destroy两个函数，用于创建类对象。
（create函数设为static,原因是，创建对象的时候A *p=A::create().只有静态成员函数才能有类名直接访问）:

```c++
	class A{
	protected:
		A(){};
		~A(){};
	public:
		static A* creat(){
			return new A();
		}
		void destroy(){
			delete this;
		}
	};
	int main()
	{
		A* a = A::creat();
		a->solve();
		a->destroy();
	}
```
 - 只能建立在栈上
   只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设为私有即可。代码如下：

```c++
	class A
	{
	private:
		void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的  
		void operator delete(void* ptr){} // 重载了new就需要重载delete  
	public:
		A(){}
		~A(){}
	};
```
- const关键字的作用？（const成员函数，函数传递，和define的区别）

- **静态成员函数和数据成员有什么意义？**
  有时候类需要它的一些成员与类本生直接相关，而不是与类的各个对象保持关联。例如一个银行账户类可能只需要一个数据成员来表示利率。
  类似的，静态成员函数也不与任何对象绑定在一起，他们不包括this指针，作为结果静态成员不能声明成const的，我们用域运算符直接访问静态成员，虽然静态静态类的某个对象但是我们任然可以用类的对象，引用，指针来访问静态成员。
  通常情况下类的静态成员不应该在类的内部初始化，不过有时候需要const的静态成员时候，也可以，但是即使一个常量静态数据成员在类内部初始化了，通常情况下也应该在类的外部定义一下该成员。

- 模版特化的概念，为什么特化?
- **explicit是干什么用的？**
  C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。声明为explicit的构造函数不能在隐式转换中使用。

- **strcpy返回类型是干嘛用的？**
- **内存溢出有那些因素？**
	1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数
	两种情况下会出现这种内存泄露：一是在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内	存；二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存
	2. 没有正确地清除嵌套的对象指针
	3. 在释放对象数组时在delete中没有使用方括号
	4. 指向对象的指针数组不等同于对象数组
	对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间
	指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了
	5. 缺少拷贝构造函数
	6. 两次释放相同的内存是一种错误的做法，同时可能会造成堆的奔溃。
	按值传递会调用（拷贝）构造函数，引用传递不会调用。
	在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。
	所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符
	7. 没有将基类的析构函数定义为虚函数

- **new与malloc的区别，delet和free的区别？**
	1. malloc与free是C/C\++语言的标准库函数，new/delete是C++的运算符。
	2. 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free,因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete.
	3. C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。
	4. new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针

- **为什么要用static\_cast转换而不用c语言中的转换？**
  与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题追踪起来也更加困难。

- 异常机制是怎么回事？
- 迭代器删除元素的会发生什么？
- 必须在构造函数初始化式里进行初始化的数据成员有哪些？
- 类的封装：private，protected，public
- auto\_ptr类：



- 抽象类、接口
抽象类是包含纯虚函数的类
C++中的接口是指只包含纯虚函数的抽象类，不能被实例化。
一个类可以实现多个接口（多重继承）

- 虚继承
作用：为了解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。
这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。这样不仅就解决了二义性问题，也节省了内存，避免了数据不一致的问题。
底层实现原理：底层实现原理与编译器相关，一般通过虚基类指针实现，即各对象中只保存一份父类的对象，多继承时通过虚基类指针引用该公共对象，从而避免菱形继承中的二义性问题。
多继承的二义性

- 构造函数中可不可以抛出异常？析构函数呢？
理论上都可以抛出异常。
但析构函数最好不要抛出异常，将会导致析构不完全，从而有内存泄露

- 构造函数和析构函数中调用虚函数
可以，虚函数底层实现原理

- 面向对象的特性

- 指针和引用
★ 区别：
1.指针是一个实体，而引用仅是个别名；
2.引用使用时无需解引用(*)，指针需要解引用；
3.引用只能在定义时被初始化一次，之后不可变；指针可变；
4.引用没有const，指针有const；
5.引用不能为空，指针可以为空；
6.“sizeof引用”得到的是所指向的变量(对象)的大小，而“sizeof指针”得到的是指针本身(所指向的变量或对象的地址)的大小；
7.指针和引用的自增(++)运算意义不一样；
8.从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域

- 基类析构函数为虚函数
在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，如果只调用基类的析构函数，则派生类没有释放掉，造成内存泄漏



- 构造函数调用顺序
先调用基类构造函数
在调用成员类构造函数
最后调用本身的构造函数
析构顺序相反

- 类A的大小是 所有非静态成员变量大小之和+虚函数指针大小
- 多线程加锁
多线程调用时要进行保护时，主要是针对全局变量和静态变量的，函数内的局部变量不会受到影响

- 拷贝构造函数
 - 三种调用拷贝构造函数的情况：
	1. 需要用一个对象去初始化同一个类的另一个新对象；
	2. 函数调用时，形参和实参的结合
	3. 函数返回值为对象时
 - 浅拷贝和深拷贝
	浅拷贝是指在对象赋值时，只对对象中的数据成员进行简单的赋值，但对于存在动态成员（指针等），就会出现问题，使得两个对象的动态成员指向了同一个地址，而不是不同地址，内容相同。

- const的四种用法
1. 修饰常量
2. 修饰函数参数 参数作为指针、引用传递时才有意义，值传递无意义 
3. 修饰函数返回值 
4. 修饰函数的定义体：任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性

- 内存管理
 - 简单理解：
	1. 静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。
	2. 栈区：在执行函数时，函数（包括main函数）内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。（任何变量都处于站区，例如int a[] = {1, 2},变量a处于栈区。数组的内容也存在于栈区。） 
	3. 堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，并立即将指针置位NULL，防止产生野指针。 
  - 栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 
  - 堆：就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。 
  - 自由存储区：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
  - 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。 
  - 常量区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改


