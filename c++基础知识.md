- 多态性都有哪些？（静态和动态，然后分别叙述了一下虚函数和函数重载）
多态：指当不同的对象收到相同的消息时，产生不同的动作
编译时多态：函数重载、运算符重载——静态绑定
运行时多态：虚函数机制——动态绑定
- 重写、重载、重定义
 - 重写(override):
	父类与子类之间的多态性。子类重新定义父类中有相同名称和参数的虚函数。
	1. 被重写的函数不能是static的。必须是virtual的(即函数在最原始的基类中被声明为virtual )。
	2. 重写函数必须有相同的类型，名称和参数列表(即相同的函数原型)
	3. 重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public,protected也是可以的
 - 重载(overload):
	指函数名相同，但是它的参数表列个数或顺序，类型不同。但是不能靠返回类型来判断。
 - 重定义(redefining):
 	子类重新定义父类中有相同名称的非虚函数(参数列表可以不同)。
	重写与重载的区别 (override) PK (overload)
	1. 方法的重写是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关   系，是水平关系。
	2. 重写要求参数列表相同；重载要求参数列表不同。
	3. 重写关系中，调用那个方法体，是根据对象的类型（对象对应存储空间类型）来决定；重载关系，是根据调用时的实参表与形参表来选择方法体的。

- 动态绑定怎么实现？（就是基类与派生类指针和引用的转换问题

- c++的四种类型强制转换
 1. dynamic_cast：该转换符用于将一个指向派生类的基类指针或引用转换为派生类的指针或引用
 2. const_cast：最常用的用途就是删除const属性；
 3. static_cas：该操作符用于非多态类型的转换，任何标准转换都可以使用他，即static_cast可以把int转换为double，但不能把两个不相关的类对象进行转换，比如类A不能转换为一个不相关的类B类型。static_cast本质上是传统c语言强制转换的替代品。
 4. reinterpret_cast：该操作符用于将一种类型转换为另一种不同的类型，比如可以把一个整型转换为一个指针，或把一个指针转换为一个整型，因此使用该操作符的危险性较高，一般不应使用该操作符。

- 操作符重载（+操作符），具体如何去定义，？（让把操作符重载函数原型说一遍）
- 内存对齐的原则？（原则叙述了一下并举例说明）
- 模版怎么实现？
- 指针和const的用法？（就是四种情况说了一下）
- 虚函数、纯虚函数、虚函数与析构函数？（纯虚函数如何定义，为什么析构函数要定义成虚函数）
- 内联函数与宏
	1. 内联函数在运行时可调试，而宏定义不可以;
	2. 编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会；
	3. 内联函数可以访问类的成员变量，宏定义则不能；
	4. 在类中声明同时定义的成员函数，自动转化为内联函数
	5. 宏只是预定义的函数，在编译阶段不进行类型安全性检查，在编译的时候将对应函数用宏命令替换。对程序性能无影响

- const和typedef（主要讲了const的用处，有那些优点
- 排序算法有哪些？快速排序怎么实现的？最好时间复杂度，平均时间复杂度
	排序算法|最坏时间复杂度啊|平均时间复杂度|空间复杂度
	-------|--------------|-----------|
	冒泡排序|$n^2$         |$n^2$	  |O(1)
	计数排序|$n^2$         |$n^2$      |O(1)
	插入排序|$n^2$		  |$n^2$      |O(1)
	选择排序|$n^2$         |$n^2$	  |O(1)
	堆排序  |$nlogn$       |$nlogn$	  |N(1)
	归并排序|$nlogn$       |$nlogn$    |N(n)
	快速排序|$n^2$         |$nlogn$    |O($nlogn$)

- 链接指示：extern “C”（作用）
- c语言和c++有什么区别？（大体讲了 一下，继承、多态、封装、异常处理等）
- stl有哪些容器，对比vector和set？
- 继承机制中对象之间是如何转换的？
- 继承机制中引用和指针之间如何转换？
- 虚函数，虚函数表里面内存如何分配？（这个考前看过了，答的还不错）
- 如何实现只能动态分配类对象，不能定义类对象？（这个牛客上的题目，我把如何只能动态分配和只能静态分配都讲了一下）
- const关键字的作用？（const成员函数，函数传递，和define的区别）
- 静态成员函数和数据成员有什么意义？
- 模版特化的概念，为什么特化？
- explicit是干什么用的？
- strcpy返回类型是干嘛用的？
- 内存溢出有那些因素？
- new与malloc的区别，delet和free的区别？
	1. malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。
	2. 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free,因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete.
	3. C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。
	4. new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针

- 为什么要用static\_cast转换而不用c语言中的转换？
- 异常机制是怎么回事？
- 迭代器删除元素的会发生什么？
- 必须在构造函数初始化式里进行初始化的数据成员有哪些？
- 类的封装：private，protected，public
- auto\_ptr类：



- 抽象类、接口
抽象类是包含纯虚函数的类
C++中的接口是指只包含纯虚函数的抽象类，不能被实例化。
一个类可以实现多个接口（多重继承）

- 虚继承
作用：为了解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。
这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。这样不仅就解决了二义性问题，也节省了内存，避免了数据不一致的问题。
底层实现原理：底层实现原理与编译器相关，一般通过虚基类指针实现，即各对象中只保存一份父类的对象，多继承时通过虚基类指针引用该公共对象，从而避免菱形继承中的二义性问题。
多继承的二义性

- 构造函数中可不可以抛出异常？析构函数呢？
理论上都可以抛出异常。
但析构函数最好不要抛出异常，将会导致析构不完全，从而有内存泄露

- 构造函数和析构函数中调用虚函数
可以，虚函数底层实现原理

- 面向对象的特性


- 指针和引用
★ 区别：
1.指针是一个实体，而引用仅是个别名；
2.引用使用时无需解引用(*)，指针需要解引用；
3.引用只能在定义时被初始化一次，之后不可变；指针可变；
4.引用没有const，指针有const；
5.引用不能为空，指针可以为空；
6.“sizeof引用”得到的是所指向的变量(对象)的大小，而“sizeof指针”得到的是指针本身(所指向的变量或对象的地址)的大小；
7.指针和引用的自增(++)运算意义不一样；
8.从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域

- 基类析构函数为虚函数
在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，如果只调用基类的析构函数，则派生类没有释放掉，造成内存泄漏



- 构造函数调用顺序
先调用基类构造函数
在调用成员类构造函数
最后调用本身的构造函数
析构顺序相反

- 类A的大小是 所有非静态成员变量大小之和+虚函数指针大小
- 多线程加锁
多线程调用时要进行保护时，主要是针对全局变量和静态变量的，函数内的局部变量不会受到影响

- 拷贝构造函数
 - 三种调用拷贝构造函数的情况：
	1. 需要用一个对象去初始化同一个类的另一个新对象；
	2. 函数调用时，形参和实参的结合
	3. 函数返回值为对象时
 - 浅拷贝和深拷贝
	浅拷贝是指在对象赋值时，只对对象中的数据成员进行简单的赋值，但对于存在动态成员（指针等），就会出现问题，使得两个对象的动态成员指向了同一个地址，而不是不同地址，内容相同。

- const的四种用法
1. 修饰常量
2. 修饰函数参数 参数作为指针、引用传递时才有意义，值传递无意义 
3. 修饰函数返回值 
4. 修饰函数的定义体：任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性

- 内存管理
 - 简单理解：
	1. 静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。 
	2. 栈区：在执行函数时，函数（包括main函数）内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。（任何变量都处于站区，例如int a[] = {1, 2},变量a处于栈区。数组的内容也存在于栈区。） 
	3. 堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，并立即将指针置位NULL，防止产生野指针。 
  - 栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 
  - 堆：就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。 
  - 自由存储区：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
  - 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。 
  - 常量区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改

