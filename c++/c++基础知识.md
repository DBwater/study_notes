- **实现strcpy函数**
```c
char * strcpy(char *dest,const char *src)
{
   assert((dest!=NULL)&&(src!=NULL));
   char *result=dest;
   while((*dest++=*src++)!='\0');
   return result;
}
```

- **多态性都有哪些？（静态和动态，然后分别叙述了一下虚函数和函数重载)**

	多态：指当不同的对象收到相同的消息时，产生不同的动作
	- 编译时多态：函数重载、运算符重载——静态绑定
	- 运行时多态：虚函数机制——动态绑定

-  **重写、重载、重定义**
	- 重写(override):

		父类与子类之间的多态性。子类重新定义父类中有相同名称和参数的虚函数。
		1. 被重写的函数不能是static的。必须是virtual的(即函数在最原始的基类中被声明为virtual )。
		2. 重写函数必须有相同的类型，名称和参数列表(即相同的函数原型)
		3. 重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public,protected也是可以的
	- 重载(overload):

	指函数名相同，但是它的参数表列个数或顺序，类型不同。但是不能靠返回类型来判断。
	 - 重定义(redefining):

	子类重新定义父类中有相同名称的非虚函数(参数列表可以不同)。
	- 重写与重载的区别 (override) PK (overload)
		1. 方法的重写是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系。
		2. 重写要求参数列表相同；重载要求参数列表不同。
		3. 重写关系中，调用那个方法体，是根据对象的类型（对象对应存储空间类型）来决定；重载关系，是根据调用时的实参表与形参表来选择方法体的。

- **动态绑定怎么实现？（就是基类与派生类指针和引用的转换问题**

	C++ 中，通过基类的引用或指针调用虚函数时，发生动态绑定。引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指对象的实际类型所定义的。

- **c++的四种类型强制转换**

	1. dynamic_cast：该转换符用于将一个指向派生类的基类指针或引用转换为派生类的指针或引用
	2. const_cast：最常用的用途就是删除const属性；
	3. static_cast：该操作符用于非多态类型的转换，任何标准转换都可以使用他，即static_cast可以把int转换为double，但不能把两个不相关的类对象进行转换，比如类A不能转换为一个不相关的类B类型。static_cast本质上是传统c语言强制转换的替代品。
	4. reinterpret_cast：该操作符用于将一种类型转换为另一种不同的类型，比如可以把一个整型转换为一个指针，或把一个指针转换为一个整型，因此使用该操作符的危险性较高，一般不应使用该操作符。

- **操作符重载（+操作符），具体如何去定义，？（让把操作符重载函数原型说一遍）**
	- 重载类的成员函数运算符
	<函数类型> operator <运算符>(<参数表>)
	- 重载类的友元函数运算符
	 friend <函数类型> operator <运算符>(<参数表>)
	- 两种重载函数比较
		- 一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。
		- 以下一些双目运算符不能重载为类的友元函数：=、()、[]、->。
		- 类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。
		- 若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。
		- 若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数。
		- 当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一　个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部　类型的对象，该运算符函数必须作为一个友元函数来实现。
		- 当需要重载运算符具有可交换性时，选择重载为友元函数。

- **内存对齐的原则？**
	- 对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是  这个数据成员的自身长度(或者可以自己设置)的倍数。
	- 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储
	- 结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐.

```c++
	typedef struct A{
		int a;//0~4
		double b;//根据规则一，偏移量应该为sizeof(double)的倍数；8~15
		char c;本来应该16~17但是根据规则三，最后补位16~23
	}A;//所以A的大小应该为24
	
	struct B{
		int id;0~4
		A a;//规矩规则二,应该为8~31;
	};
	//所以最后的大小应该为32
```

- **模版怎么实现？**
```
template\<typename T>
中间不能有任何其他定义
void swap(T a,T b){}
```

- **模板的优缺点**
	优点：
	- 在一些场景可以避免重复代码
	- 有些问题难以使用OO技巧（如继承和多态）来实现，而使用模版会很方便
	- template classes更加的类型安全，因其参数类型在编译时都是已知的。
	缺点：
	- 一些编译器对template支持不好。
	- 编译器给出的有些出错信息比较晦涩。
	- 为每种类型都生成额外的代码，可能导致生成的exe膨胀。
	- 使用templates写的代码难以调试
	- templates在头文件中，这样一旦有所变更需要重编译所有相关工程

- **模版特化的概念，为什么特化?**

	模板有两种特化，全特化和偏特化（局部特化）
	模板函数只能全特化，没有偏特化（以后可能有）。
	模板类是可以全特化和偏特化的。
	全特化，就是模板中模板参数全被指定为确定的类型。
	全特化也就是定义了一个全新的类型，全特化的类中的函数可以与模板类不一样。
	偏特化，就是模板中的模板参数没有被全部确定，需要编译器在编译时进行确定。
	在类型上加上const、&、\*（ cosnt int、int&、int\*、等等）并没有产生新的类型。只是类型被修饰了。模板在编译时，可以得到这些修饰信息。


- **指针和const的用法？**
	- const char *s;
	- char *const s;
	- const char* const s;
	- char* s;

- **虚函数、纯虚函数、虚函数与析构函数？(纯虚函数如何定义，为什么析构函数要定义成虚函数）**
	- 纯虚函数只指定具体的接口继承
	- 虚函数具体指定接口继承以及缺省实现继承
	- 非虚函数具体制定结构继承和强制性实现
	- 析构函数函数定义成virtrual为了防止用父类指针指向子类时候析构不完整，造成内存泄露

- **内联函数与宏**
	1. 内联函数在运行时可调试，而宏定义不可以;
	2. 编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会；
	3. 内联函数可以访问类的成员变量，宏定义则不能；
	4. 在类中声明同时定义的成员函数，自动转化为内联函数
	5. 宏只是预定义的函数，在编译阶段不进行类型安全性检查，在编译的时候将对应函数用宏命令替换。对程序性能无影响

- **排序算法有哪些？快速排序怎么实现的？最好时间复杂度，平均时间复杂度**

	排序算法|最坏时间复杂度啊|平均时间复杂度|空间复杂度
	-------|--------------|-----------|--------
	冒泡排序|$n^2$         |$n^2$	   |O(1)
	计数排序|$n^2$         |$n^2$      |O(1)
	插入排序|$n^2$		   |$n^2$      |O(1)
	选择排序|$n^2$         |$n^2$	   |O(1)
	堆排序  |$nlogn$       |$nlogn$    |O(1)
	归并排序|$nlogn$       |$nlogn$    |O(n)
	快速排序|$n^2$         |$nlogn$    |$nlogn$

- **链接指示：extern “C”（作用）**
	- extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。
	- 也就是说extern有两个作用，第一个,当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的"脾气"了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊,C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。
	- 当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g\_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。


- **c语言和c++有什么区别？（大体讲一下，继承、多态、封装、异常处理等）**
	- C++在C的基础上增添类

	C是一个结构化语言，它的重点在于算法和数据结构。

	C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。
	- 封装：封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。封装的意义在于保护或者防止代码（数据）被我们无意中破坏。

	- 继承：继承主要实现重用代码，节省开发时间。子类可以继承父类的一些东西。
	- 多态: 同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。

- **stl有哪些容器，对比vector和set？**
 	STL容器分为顺序容器和关联容器。
	- 顺序容器主要有vector、list、deque、string、array等。其中vector表示一段连续的内存，基于数组实现，list表示非连续的内存，基于链表实现，deque与vector类似，但是对首元素提供插入和删除的双向支持。
	- 关联容器主要有map、multimap、unordered_map、set、multiset、unorderd_set等。map是key-value形式，set是单值。map和set只能存放唯一的key，multimap和multiset可以存放多个相同的key。
		1. 首先，vector是顺序容器，而set是关联式容器;set包含0个或多个不重复不排序的元素。也就是说set能够保证它里面所有的元素都是不重复的；另外，对set容器进行插入时可以指定插入位置或者不指定插入位置。如insert(v.begin(),1),也可以直接用insert(1)。还有一点是set对一些操作符没有进行重载，如<。
		2. vector和deque的区别主要在于他们底层的实现不同，特别是在插入和删除操作的实现机制不同。
		3. 对于vector来说，不管其大小是多少，在头部插入的效率总是比在尾部插入的效率低。在尾部插入将耗费固定的时间。在头部进行插入时，耗费的时间与vector的大小成正比，vector越大，耗费的时间越多。例如，在一个大小为1000的vector头部插入一个元素，与在一个大小为10的vector头部插入一个元素相比，将耗费100倍的时间。删除操作的情形也与插入类似。因此，vector适合于插入和删除操作都在尾部进行的情况。
		4. deque和vector不同，不管进行的插入还是删除操作，也不管这些操作时在头部还是尾部进行，算法的效率是固定的。例如：不管deque的大小是10，100，还是1000.deque在头部和尾部插入删除的时间是一样的。因此要在对于两端进行插入或者删除操作时。deque要优于vector。

- **继承机制中对象之间是如何转换的？**
	- 向上转型：向上转型是隐式转换。
   将子类对象看作是父类对象,平行四边形是四边形的一种，那么就可以将平行四边形对象看作是一个四边形对象
	- 向下转型
 将抽象类转换为较具体的类，这样的转型通常会出现问题，例如，不能说四边形是平行四边形的一种


- 继承机制中引用和指针之间如何转换？

- 虚函数，虚函数表里面内存如何分配？（这个考前看过了，答的还不错）

- **如何实现只能动态分配类对象，不能定义类对象？**

	动态分配类对象：就是使用运算符new来创建一个类的对象，在堆上分配内存。
	静态分配类对象：就是A a，由编译器创建类对象，在栈上分配内存。
	- 动态分配类对象
	把类的构造函数和析构函数设为protected属性。类对象不能访问，但是派生类可以继承，也可以访问。
	同时，创建create和destroy两个函数，用于创建类对象。
	（create函数设为static,原因是，创建对象的时候A *p=A::create().只有静态成员函数才能有类名直接访问）:

	```c++
	class A{
	protected:
		A(){};
		~A(){};
	public:
		static A* creat(){
			return new A();
		}
		void destroy(){
			delete this;
		}
	};
	int main()
	{
		A* a = A::creat();

		a->destroy();
	}
	```

	- 只能建立在栈上
	只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设为私有即可。代码如下：

	```c++
	class A
	{
	private:
		void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的
		void operator delete(void* ptr){} // 重载了new就需要重载delete
	public:
		A(){}
		~A(){}
	};
	```

- **const关键字的作用？（const成员函数，函数传递，和define的区别）**
	- const成员函数：称为常成员函数，可以理解为是一个“只读函数”，它既不能更改数据成员的值，也不能调用那些能引起数据成员的值变化的成员函数，只能调用const成员函数。在成员函数的声明和定义时都需要加const修饰符；
	- 函数传递：在函数调用时候，可以修饰函数的传递参数，防止参数被意外修改；也可以返回函数的返回值，表示返回值不可修改；
	- 与define的区别：
		1. const常量有数据类型，而宏定义没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换中可能会产生意想不到的错误（边际效应）。
		2. 有些集成化的调试工具可以对const常量进行调试，但是不能对宏定义进行调试。
		3. 在C++程序中只使用const常量而不使用宏常量，即const常量完全取代宏常量。
	- 内存区别：
		1. 内存空间的分配上。define进行宏定义的时候，不会分配内存空间，编译时会在main函数里进行替换，只是单纯的替换，不会进行任何检查,比如类型，语句结构等，即宏定义常量只是纯粹的置放关系，如#define null 0；编译器在遇到null时总是用0代替null它没有数据类型.而const定义的常量具有数据类型，定义数据类型的常量便于编译器进行数据检查，使程序可能出现错误进行排查,所以const与define之间的区别在于const定义常量排除了程序之间的不安全性.
		2. const常量存在于程序的数据段，#define常量存在于程序的代码段
		3. 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。

- **typedef和#define的区别**
	typedef int\*  int_ptr;
	\#define int_ptr int\*
	intptr a,b；
	- typedef会出现int \*a,\*b,
	- \#define会出现 int \*a ,b;

- **静态成员函数和数据成员有什么意义？**

	有时候类需要它的一些成员与类本生直接相关，而不是与类的各个对象保持关联。例如一个银行账户类可能只需要一个数据成员来表示利率。
	类似的，静态成员函数也不与任何对象绑定在一起，他们不包括this指针，作为结果静态成员不能声明成const的，我们用域运算符直接访问静态成员，虽然静态静态类的某个对象但是我们任然可以用类的对象，引用，指针来访问静态成员。
	通常情况下类的静态成员不应该在类的内部初始化，不过有时候需要const的静态成员时候，也可以，但是即使一个常量静态数据成员在类内部初始化了，通常情况下也应该在类的外部定义一下该成员。
	优势：
	1. 静态数据成员没有进入程序全局名字空间，因此不会与程序中其他全局名字冲突。
    2. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能。
	- 静态成员函数
		1. 是为类的全部服务而不是为类的某个对象服务。
		2. 是类的内部实现，属于类定义的一部分。
		3. 由于不与任何对象相连系，因此不具有this指针。所以，无法访问类对象的非静态数据成员，也无法访问类非静态成员函数，只能访问静态数据成员，调用静态成员函数。


- **explicit是干什么用的？**

  C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。声明为explicit的构造函数不能在隐式转换中使用。

- **strcpy返回类型是干嘛用的？**
- **内存溢出有那些因素？**
	1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数
	两种情况下会出现这种内存泄露：一是在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内	存；二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存
	2. 没有正确地清除嵌套的对象指针
	3. 在释放对象数组时在delete中没有使用方括号
	4. 指向对象的指针数组不等同于对象数组
	对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间
	指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了
	5. 缺少拷贝构造函数
	6. 两次释放相同的内存是一种错误的做法，同时可能会造成堆的奔溃。
	按值传递会调用（拷贝）构造函数，引用传递不会调用。
	在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。
	所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符
	7. 没有将基类的析构函数定义为虚函数

- **new与malloc的区别，delet和free的区别？**
	1. malloc与free是C/C\++语言的标准库函数，new/delete是C++的运算符。
	2. 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free,因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete.
	3. C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。
	4. new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针
	5. new能够自动计算需要分配的内存，而malloc需要手动计算字节数。

- **为什么要用static\_cast转换而不用c语言中的转换？**

	与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题追踪起来也更加困难。

- **异常机制是怎么回事？**

	异常处理允许用户以一种有序的方式管理运行是出现的错误。使用C＋＋的异常处理，用户程序在错误发生时可自动调用一个错误处理程序。异常处理最主要的优点是自动转向错误处理代码,C＋＋异常处理建立在三个关键字基础之上：try、catch和throw,通常，监测异常情况的程序语句包含在try中。如果try块中发生了异常（也就是错误），则用throw处理。异常由catch捕获，并得到处理。

- **迭代器删除元素的会发生什么？**
	-  对于关联容器(如map, set, multimap,multiset)，删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。
	- 对于序列式容器(如vector,deque)，删除当前的iterator会使后面所有元素的iterator都失效。这是因为vetor,deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。还好erase方法可以返回下一个有效的iterator
	- 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种方法都可以使用。
- **必须在构造函数初始化式里进行初始化的数据成员有哪些？**
	- 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
	- 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
	- 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化

- **类的封装：private，protected，public**
	1. 公有继承（public）：
	基类成员对其对象的可见性与一般类及其对象的可见性相同，public成员可见，protected和private成员不可见,基类成员对派生类的可见性对派生类来说，基类的public和protected成员可见：基类的public成员和protected成员作为派生类的成员时，它们都保持原有状态；基类的private成员依旧是private，派生类不可访问基类中的private成员。
	基类成员对派生类对象的可见性对派生类对象来说，基类的public成员是可见的，其他成员是不可见的。
	所以，在公有继承时，派生类的对象可以访问基类中的public成员，派生类的成员方法可以访问基类中的public成员和protected成员。
	2. 私有继承（private）
	基类成员对其对象的可见性与一般类及其对象的可见性相同，public成员可见，其他成员不可见,基类成员对派生类的可见性对派生类来说，基类的public成员和protected成员是可见的：基类的public成员和protected成员都作为派生类的private成员，并且不能被这个派生类的子类所访问；基类的私有成员是不可见的：派生类不可访问基类中的private成员,基类成员对派生类对象的可见性对派生类对象来说，基类的所有成员都是不可见的,所以在私有继承时，基类的成员只能由直接派生类访问，无法再往下继承。
	3. 保护继承（protected）
	保护继承与私有继承相似，基类成员对其对象的可见性与一般类及其对象的可见性相同，public成员可见，其他成员不可见,基类成员对派生类的可见性，对派生类来说，基类的public和protected成员是可见的：基类的public成员和protected成员都作为派生类的protected成员，并且不能被这个派生类的子类所访问；基类的private成员是不可见的：派生类不可访问基类中的private成员。基类成员对派生类对象的可见性对派生类对象来说，基类的所有成员都是不可见的。所以，在保护继承时，基类的成员也只能由直接派生类访问，而无法再向下继承。C++支持多重继承。多重继承是一个类从多个基类派生而来的能力。派生类实际上获取了所有基类的特性。当一个类 是两个或多个基类的派生类时，派生类的构造函数必须激活所有基类的构造函数，并把相应的参数传递给它们 。

- **auto_ptr类：**

	auto_ptr是C++标准库中< utility >为了解决资源泄漏的问题提供的一个智能指针类模板（注意：这只是一种简单的智能指针)auto_ptr的实现原理其实就是RAII，在构造的时候获取资源，在析构的时候释放资源，并进行相关指针操作的重载，使用起来就像普通的指指针

	```c
	std::auto_ptr< ClassA > pa(new ClassA);
	```

- **智能指针**

	- shared_ptr:允许多个指针指向同一个对象，可以使用make_shared函数来分配一个对象
	- unique_ptr:独占所指向的对象
	- weak_ptr:它是一种弱引用，指向shared_ptr所管理的对象，但是不增加shared_ptr的计数器，访问的时候必须先检查shared_ptr是否存在。
	可以自定义删除器。



- **抽象类、接口**

	抽象类是包含纯虚函数的类
	C++中的接口是指只包含纯虚函数的抽象类，不能被实例化。
	一个类可以实现多个接口（多重继承）

- **虚继承**

	作用：为了解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。
	这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。这样不仅就解决了二义性问题，也节省了内存，避免了数据不一致的问题。
	底层实现原理：底层实现原理与编译器相关，一般通过虚基类指针实现，即各对象中只保存一份父类的对象，多继承时通过虚基类指针引用该公共对象，从而避免菱形继承中的二义性问题。
	多继承的二义性

- **构造函数中可不可以抛出异常？析构函数呢？**

	理论上都可以抛出异常。
	但析构函数最好不要抛出异常，将会导致析构不完全，从而有内存泄露

- 内联函数、构造函数、静态成员函数可以是虚函数吗？

	都不可以。
	- 内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开
	- 构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类 的，因此不存在动态绑定的概念；
	- 静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的，因此是两个冲突的概念；

- **构造函数和析构函数中可以调用调用虚函数吗？**

	可以，虚函数底层实现原理(但是最好不要在构造和析构函数中调用)
	可以，但是没有动态绑定的效果，父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数。
	effictive c++第九条，绝不在构造和析构过程中调用virtual,因为构造函数中的base的虚函数不会下降到derived上。而是直接调用base类的虚函数。

- **面向对象的特性**

- **指针和引用**

	区别：
	1. 指针是一个实体，而引用仅是个别名；
	2. 引用使用时无需解引用(\*)，指针需要解引用；
	3. 引用只能在定义时被初始化一次，之后不可变；指针可变；
	4. 引用没有const，指针有const；
	5. 引用不能为空，指针可以为空；
	6. “sizeof引用”得到的是所指向的变量(对象)的大小，而“sizeof指针”得到的是指针本身(所指向的变量或对象的地址)的大小；
	7. 指针和引用的自增(++)运算意义不一样；
	8. 从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域

- **基类析构函数为虚函数**
	在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，如果只调用基类的析构函数，则派生类没有释放掉，造成内存泄漏



- **构造函数调用顺序**
	1. 先调用基类构造函数
	2. 在调用成员类构造函数
	3. 最后调用本身的构造函数
	4. 析构顺序相反

- **类A的大小是 所有非静态成员变量大小之和+虚函数指针大小**
- **多线程加锁**
	多线程调用时要进行保护时，主要是针对全局变量和静态变量的，函数内的局部变量不会受到影响

- **拷贝构造函数**
	- 三种调用拷贝构造函数的情况：
		1. 需要用一个对象去初始化同一个类的另一个新对象；
		2. 函数调用时，形参和实参的结合
		3. 函数返回值为对象时
	- 浅拷贝和深拷贝
	浅拷贝是指在对象赋值时，只对对象中的数据成员进行简单的赋值，但对于存在动态成员（指针等），就会出现问题，使得两个对象的动态成员指向了同一个地址，而不是不同地址，内容相同。

- **const的四种用法**
	1. 修饰常量
	2. 修饰函数参数 参数作为指针、引用传递时才有意义，值传递无意义
	3. 修饰函数返回值
	4. 修饰函数的定义体：任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性

- **内存管理**
	- 简单理解：
		1. 静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。
		2. 栈区：在执行函数时，函数（包括main函数）内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。（任何变量都处于站区，例如int a[] = {1, 2},变量a处于栈区。数组的内容也存在于栈区。）
		3. 堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，并立即将指针置位NULL，防止产生野指针。
	- 栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 
	- 堆：就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。 
	- 自由存储区：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
	- 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。 
	- 常量区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改

**一个简答的string函数**
```c++
#include<iostream>
#include<cstring>
using std::ostream;
class string{
public:
	string(const char* str);
	string(const string& str);
	~string();
	string& operator=(const string& str);
	friend ostream& operator<<(ostream& os,const string& str){
		os<<str.m_str;
		return os;
	}
private:
	char* m_str;
};
//构造函数
string::string(const char* str){
	if(str==NULL){
		m_str=NULL;
	}
	else{
		m_str = new char[strlen(str)+1];//可能需要判断是否new成功，为了减少代码量，不考虑异常
		memcpy(m_str,str,sizeof(str));
	}
}
//拷贝构造函数
string::string(const string& str){
	m_str = new char[strlen(str.m_str)+1];
	memcpy(m_str,str.m_str,sizeof(str.m_str));
}
//拷贝赋值运算符
string& string::operator= (const string& str){
	if(this!=&str){
		if(m_str!=NULL){
			delete m_str;
			m_str=NULL;
		}
		m_str = new char[strlen(str.m_str)+1];
		memcpy(m_str,str.m_str,sizeof(str.m_str));
	}
	return *this;
}
//析构函数
string::~string(){
	if(m_str!=NULL){
		delete m_str;
		m_str=NULL;
	}
}


```




