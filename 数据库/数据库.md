- **数据库的两种引擎**

	- Innodb引擎

		Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这篇文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。

	- MyIASM引擎

		MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。

	- 两种引擎的选择

		大尺寸的数据集趋向于选择InnoDB引擎，因为它支持事务处理和故障恢复。数据库的大小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。大批的INSERT语句(在每个INSERT语句中写入多行，批量插入)在MyISAM下会快一些，但是UPDATE语句在InnoDB下则会更快一些，尤其是在并发量大的时候。

- **什么是存储过程？有哪些优缺点？**
	- 存储过程是一些预编译的SQL语句。
	- 更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。
	- 存储过程是一个预编译的代码块，执行效率比较高
	- 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率
	- 可以一定程度上确保数据安全


- **索引是什么？有什么作用以及优缺点？**
	- 索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构
	- 你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。
	- MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引
	- 索引的优点
		- 索引加快数据库的检索速度
		- 索引降低了插入、删除、修改等维护任务的速度
		- 唯一索引可以确保每一行数据的唯一性
		- 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
		- 索引需要占物理和数据空间
- **什么是事务？**

	事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。

- **事务的四大特性**
	**如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：**
	1. 原子性（Atomicity）
　	原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

	2. 一致性（Consistency）
　　	一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
	拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
	3. 隔离性（Isolation）
　　	隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
	即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
	关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。
	4. 持久性（Durability）
　　	持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

	例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。


- **数据库的乐观锁和悲观锁是什么？**

	数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。

	乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。
	- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
	- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

- **使用索引查询一定能提高查询的性能吗？为什么**

	通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.

	索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:
	- 基于一个范围的检索,一般查询返回结果集小于表中记录数的30%
	- 基于非唯一性索引的检索

- **简单说一说drop、delete与truncate的区别**

	SQL中的drop、delete、truncate都表示删除，但是三者有一些差别

	- delete和truncate只删除表的数据不删除表的结构
	- 速度:一般来说: drop> truncate >delete
	- delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;
	- 如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.

- **drop、delete与truncate分别在什么场景之下使用？**
	- 不再需要一张表的时候，用drop
	- 想删除部分数据行时候，用delete，并且带上where子句
	- 保留表而删除所有数据的时候用truncate

- **超键、候选键、主键、外键分别是什么？**
	- 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
	- 候选键：是最小超键，即没有冗余元素的超键。
	- 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
	- 外键：在一个表中存在的另一个表的主键称此表的外键。

- **什么是视图？以及视图的使用场景有哪些？**
	- 视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。
	- 只暴露部分字段给访问者，所以就建一个虚表，就是视图。
	- 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异


- **范式**
	- 第一范式：数据库表的每一项都是不可分割的原子数据项，不能是集合。比如班级信息表里面不能有班级的学生。
	- 第二范式：在第一范式的基础上，所有属性完全依赖于主键，完全依赖就是不能取决于主键的一部分
	- 第三范式：在第二范式的基础上，消除传递依赖，比如学生表里有学生属于的班级编号，但不能有班级的名称，班级人数等班级信息，因为班级信息可有由班级编号通过班级表推出来，有传递依赖
	- 第一范式->第二范式->第三范式
	→→→数据冗余越来越少，查询越来越复杂

	←←←有数据冗余，但查询简单

分组查询（avg max min）、复杂连接查询、嵌套查询、结果排序（逆序ansc）、